Spring Integration Tutorial
============================================
:Author:    Tejas Mehta
:Email:     tmehta@redhat.com
:Date:      22/11/2012
============================================
What is Spring Integration?
---------------------------
Spring Integration is an extension to the Spring Framework that adds support for Enterprise Integration Patterns (https://www.youtube.com/watch?v=Xwi1DU6KoQ4).
It essentially adds support for messaging within an application and integration with external systems. Here I will highlight both using a business use case of a Cafe.

In case you are curious, here is the finished product: https://cafe-tmehta.rhcloud.com/cafe-web and https://cafe-tmehta.rhcloud.com/cafe-processing

.Domain:

Here is a quick overview of the domain use case:

----        
                                                                                         Barista
                                                                     hotDrinks       ____________________        
                                                                    |==========| -->|                    |
                     orders                   drinks               /                | prepareHotDrink()  |	preparedDrinks
Place Order ->Cafe->|======|->OrderSplitter->|======|->DrinkRouter                  |                    |-->|==========| 
                                                                   \ coldDrinks     | prepareColdDrink() |
                                                                    |==========| -->|                    |
                                                                                    |____________________|

                                                    Legend: |====| - channels
                                                    	    ->*-> - Message Endpoints (Filters)
----													

Based on the use case, we have the following domain level classes:

1. Cafe - Takes in orders
2. Order - Consists a list of OrderItems
3. OrderItems - Type of order, how many cups/shots, etc.
4. Drink - Individual Drinks

From the business model perspective: The role of the user ends once they have placed an order and the Cafe and its staff takes over after that. 
Therefore, the business use case is split into two applications, one a Web Interface that uses a Spring MVC form to place orders and the other a order processing module. This division of labour follows good programming practices and also helps illustrate Spring Integrations prowess in allowing integration with external systems.
Both these applications will use the domain objects so without further ado here is code snippet for the domain objects:

[source,java]
----
@Entity
public class Order implements Serializable {

	...
	
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
	private List<OrderItem> orderItems = new ArrayList<OrderItem>();

	@Id
	@GeneratedValue
	private int id;
	
	...
	
}

@Entity
public class OrderItem implements Serializable {

    private DrinkType type;

    private int shots = 1;

    private boolean iced = false;    
    
    @Id
    @GeneratedValue
    private int id;
    
    /** the order this item is tied to */
	private int orderNumber;
	
	...
	
}


public enum DrinkType {

	ESPRESSO,
	LATTE,
	CAPPUCCINO,
	MOCHA

}

@Entity
public class Drink {
	
	@Id
	@GeneratedValue
	private int id;
	
    private boolean iced;

    private int shots;

    private DrinkType drinkType;
    
	private int orderNumber;
	
	...
	
}


@Entity
public class Delivery {
	
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    private List<Drink> deliveredDrinks;

    @Id
    @GeneratedValue
    private int id;    
    
	private int orderNumber;
	
	...
}
----

The classes are annotated with @Entity as to allow persistence and Order and OrderItem implement Serializable to allow transmission across applications.

First I will show how to design the web and processing modules as separate applications and then later show how to configure them to 

.Web Module:

The web module is responsible for the *Place Order ->...* part of the use case. The web module is written using Spring MVC (a good tutorial on Spring MVC: <link/>). It consists of a Order form and an Order Item form. In addition to Spring MVC, the form also uses a bit of Javascript to increase the interactivety of the application.
Here is the relevant bits of code:

[source,java]
----
@Controller
@RequestMapping("/order")
public class OrderController {
	...
	
	@RequestMapping(method = RequestMethod.POST)
	@ResponseStatus(HttpStatus.CREATED)
	public @ResponseBody String orderCreate(Order order) throws IOException {
		order.setNumber(getID());
		for (OrderItem orderitem : order.getOrderItems()) {
			orderitem.setOrderNumber(order.getNumber());
		}
		
		cafe.placeOrder(order);
		return "Successfully created Order #: " + order.getNumber();
	}	
	...
}

----


[source,xml]
----
<form:form commandName="order" id="order" onsubmit="return false;">
	...
	<tr>
		<td><input type="submit" value="Submit Order" onclick="submitOrder()" /></td>
	</tr>
	...
</form:form>

<script type="text/javascript">
	function submitOrder() {					
		jq(function() {
			jq.post("order", jq('#order').serialize(), function(data) {
				jq("#success").replaceWith(
						'<span id="success">' + data + '</span>');
				jq("#table").load("/cafe/status");
			});
		});
	}
</script>
----

.Processing Module:

The processing module is responsible for entire use case after the user has placed an order and it operates asynchronously from the web module.
Each stage of the use case is represented as channel in the application. This configured in the application context file:


[source,xml]
----

<!--The Spring Integration dependencies required are:-->
<dependency>
	<groupId>org.springframework.integration</groupId>
	<artifactId>spring-integration-stream</artifactId>
	<version>${spring.integration.version}</version>
</dependency>
<dependency>
	<groupId>org.springframework.integration</groupId>
	<artifactId>spring-integration-jms</artifactId>
	<version>${spring.integration.version}</version>
</dependency>
<dependency>
	<groupId>org.springframework.integration</groupId>
	<artifactId>spring-integration-jdbc</artifactId>
	<version>${spring.integration.version}</version>
</dependency>

<!--Channels and namespace configurations-->

<publish-subscribe-channel id="orders" />
<channel id="drinks" />
<channel id="coldDrinks">
	<queue capacity="10" />
</channel>
<channel id="hotDrinks">
	<queue capacity="10" />
</channel>
<channel id="coldDrinkBarista" />
<channel id="hotDrinkBarista" />
<channel id="preparedDrinks" />

<publish-subscribe-channel id="deliveries" />
----

By default <channel> defines a Spring Integration channel that can have a single subscriber, thus <publish-subscribe-channel> is used for the channels that may have multiple subscribers. <queue> creates a QueueChannel which provides message buffering capability. By default it is in-memory but can be configured to use a database if you want to avoid lost messages in case of system failure. In order to transforming/routing/splitting/aggregating orders from channel to channel we use various Spring Integration annotations:

To split orders into orderItems we have the OrderSplitter:

[source,java]
----
@MessageEndpoint
public class OrderSplitter {

	@Splitter(inputChannel="orders", outputChannel="drinks")
	public List<OrderItem> split(Order order) {
		return order.getOrderItems();
	}

}
----

The splitter simply returns the list of individual drinks ordered for each item in the orders channel and then outputs them into the drinks channel.

To categorize the drinks as hot or cold, we use a router:

[source,java]
----
@MessageEndpoint
public class DrinkRouter {

	@Router(inputChannel="drinks")
	public String resolveOrderItemChannel(OrderItem orderItem) {
		return (orderItem.getIced()) ? "coldDrinks" : "hotDrinks";
	}
}
----

The router class takes in message payload from the drinks channel and outputs which channel to route the drink to depending on whether it is a hot or cold drink.

Because the coldDrinks and hotDrinks queue buffers message, we need to setup to poller to allow a subscriber to connect. To do so, we use a <bridge>, which is configured to poll the buffering channel with a delay and move the messages to subscriber channel:

[source,xml]
----
<bridge input-channel="coldDrinks" output-channel="coldDrinkBarista">
	<poller fixed-delay="1000" />
</bridge>

<bridge input-channel="hotDrinks" output-channel="hotDrinkBarista">
	<poller fixed-delay="1000" />
</bridge>
----

Now as in real life, we have a Barista to prepare drinks:

[source,java]
----
@Component
public class Barista {
	...
	
	@ServiceActivator(inputChannel="hotDrinkBarista", outputChannel="preparedDrinks")
	public Drink prepareHotDrink(OrderItem orderItem) {
		try {
			Thread.sleep(this.hotDrinkDelay);
			System.out.println("Prepared " + orderItem.getShots() + " Hot " + orderItem.getType());
			return new Drink(orderItem.getOrderNumber(), orderItem.getType(), orderItem.getIced(),
					orderItem.getShots());
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			return null;
		}
	}

	@ServiceActivator(inputChannel="coldDrinkBarista", outputChannel="preparedDrinks")
	public Drink prepareColdDrink(OrderItem orderItem) {
		try {
			Thread.sleep(this.coldDrinkDelay);
			System.out.println("Prepared " + orderItem.getShots() + " Iced " + orderItem.getType());
			return new Drink(orderItem.getOrderNumber(), orderItem.getType(), orderItem.getIced(),
					orderItem.getShots());
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			return null;
		}
	}

}
----

The Barista subscribes to the coldDrinkBarista and hotDrinkBarista channels and prepares the drinks with appropriate delay and outputs to the prepared drinks channel.

Now with all the drinks in the preparedDrinks channel, we need a way to aggregate the drinks back into their orders. This where Spring Integration's aggregator, the opposite of splitter, comes in.


[source,java]
----
@MessageEndpoint
public class Waiter {

    @Aggregator(inputChannel = "preparedDrinks", outputChannel = "deliveries")
    public Delivery prepareDelivery(List<Drink> drinks) {
    	System.out.println("Delivered " + drinks);
        return new Delivery(drinks);
    }
    
    @CorrelationStrategy
    public int correlateByOrderNumber(Drink drink) {
    	return drink.getOrderNumber();
    }    
}
----

The aggregator works using a correlation strategy which determines the value to use to put individual objects together.

The deliveries channel is filled by the aggregator and can be subscribed to by any endpoint for any further processing/use. For this sample, we showcase the Spring Integration Channel Adapter.

We use a outbound-channel-apdater to store the deliveries in a database.

[source,xml]
----
<outbound-channel-adapter id="outboundDelivery" ref="JPAOutbound" method="addDelivery" channel="deliveries"/>
----

[source,java]
----
@MessageEndpoint("JPAOutbound")
@Transactional
public class JPAOutbound implements DBOutboundInterface {
	
	@Autowired
	private DeliveryDao deliveryDao;
		
	public void addDelivery(Delivery delivery){
		deliveryDao.saveAndFlush(delivery);
	}
}
----

For this application, we use Spring MVC to display the collected deliveries on the status page: https://cafe-tmehta.rhcloud.com/cafe-processing/

.Integration between applications:

With the web module and the processing modules developed all that is left is to do is to connect the two. Here is where Spring Integration really shines.

To show how to configure communication between the two application, we will be using JBoss AS 7. JBoss AS 7 out of the box should contain a JMS RemoteConnectionFactory and TestQueue (check the standalone.xml), not add the following lines to $JBOSS_HOME/standalone/configuration/standalone.xml inside <subsystem xmlns="urn:jboss:domain:messaging:1.1"> <hornetq-server>:

[source,xml]
----
<jms-connection-factories>
	<connection-factory name="InVmConnectionFactory">
		<connectors>
			<connector-ref connector-name="in-vm" />
		</connectors>
		<entries>
			<entry name="java:/ConnectionFactory" />
		</entries>
	</connection-factory>
	<connection-factory name="RemoteConnectionFactory">
		<connectors>
			<connector-ref connector-name="netty" />
		</connectors>
		<entries>
			<entry name="RemoteConnectionFactory" />
			<entry name="java:jboss/exported/jms/RemoteConnectionFactory" />
		</entries>
	</connection-factory>
	<pooled-connection-factory name="hornetq-ra">
		<transaction mode="xa" />
		<connectors>
			<connector-ref connector-name="in-vm" />
		</connectors>
		<entries>
			<entry name="java:/JmsXA" />
		</entries>
	</pooled-connection-factory>
</jms-connection-factories>


<jms-destinations>
	<jms-queue name="testQueue">
		<entry name="queue/test" />
		<entry name="java:jboss/exported/jms/queue/test" />
	</jms-queue>
	<jms-queue name="sportsclub">
		<entry name="queue/sportsclub" />
	</jms-queue>
	<jms-topic name="testTopic">
		<entry name="topic/test" />
		<entry name="java:jboss/exported/jms/topic/test" />
	</jms-topic>
</jms-destinations>
----
	
The web module is responsible for outputting orders onto to the testQueue, therefore we configure a outbound jms channel adapter:

[source,xml]
----
<jee:jndi-lookup jndi-name="RemoteConnectionFactory"
	id="connectionFactory"></jee:jndi-lookup>


<jms:outbound-channel-adapter id="outputQueue"
	connection-factory="connectionFactory" destination-name="testQueue"
	channel="orders">
</jms:outbound-channel-adapter>
----
	
And for the processing module we have a inbound jms channel adapter that polls the testQueue:

[source,xml]
----
<jee:jndi-lookup jndi-name="RemoteConnectionFactory"
	id="connectionFactory"></jee:jndi-lookup>

<jms:inbound-channel-adapter id="inputQueue"
	connection-factory="connectionFactory" destination-name="testQueue"
	channel="orders">
	<poller fixed-delay="1000" />
</jms:inbound-channel-adapter>
----
	
So with this you should have application capable to interacting with one another asynchronously. This tutorial provides only the base functionality of Spring Integration, there are wealth of other features that enable you further increase the complexity of your application while maintaining the simplicity of the code. More information about Spring Integration can be found at: http://static.springsource.org/spring-integration/reference/htmlsingle.
	
.Summary:

The source code for this sample can be found at https://github.com/TejasM/cafe-full. And the you can see the application in action at:

https://cafe-tmehta.rhcloud.com/cafe-web - To place orders

https://cafe-tmehta.rhcloud.com/cafe-processing - To view the processed orders
	
	
